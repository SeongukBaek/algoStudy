# [9465] 스티커

## :pushpin: **Algorithm**

DP

## :round_pushpin: **Logic**

```java
// 위쪽 값이 들어간 경우
dp[0][0] = stickers[0][0];
// 아래쪽 값이 들어간 경우
dp[0][1] = stickers[1][0];
// 위아래 둘다 안들어간 경우
dp[0][2] = 0;
for (int i = 1; i < n; i++) {
  dp[i][0] = Math.max(dp[i - 1][1], dp[i - 1][2]) + stickers[0][i];
  dp[i][1] = Math.max(dp[i - 1][0], dp[i - 1][2]) + stickers[1][i];
  dp[i][2] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][1], dp[i - 1][2]));
}

System.out.println(Math.max(dp[n - 1][0], Math.max(dp[n - 1][1], dp[n - 1][2])));
```

- 가장 처음 값을 초기화 시켜준다.
- 그리고 두번째 열부터 각 값들을 계산해준다.
- 위쪽에 값을 넣는 경우는 그 이전 열에서 아래쪽에 값을 넣은것과 둘 다 넣지 않은 경우 중 더 큰 값을 넣는다.
- 아래쪽에 값을 넣는 경우는 그 이전 열에서 위쪽에 값을 넣은것과 둘 다 넣지 않은 경우 중 더 큰 값을 넣는다.
- 둘 다 넣지 않는 경우는 그 이전 열에서 위쪽에 값은 넣은것과 아래쪽에 값을 넣은것과 둘 다 넣지 않은 경우 중 더 큰 값을 넣는다.
- 이후 마지막에 3경우 중 가장 큰 값을 출력한다.

## :black_nib: **Review**

- 비슷한 문제를 풀어봤어서 금방 생각이 떠올랐다.
- DP는 많은 유형의 문제를 풀어보면서 연습하는 방법이 좋은 것 같다.
