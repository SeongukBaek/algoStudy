# [5215] 햄버거 다이어트

## :pushpin: **Algorithm**

완전탐색, 조합

## :round_pushpin: **Logic**

주어진 재료를 가지고 제한 칼로리 이하의 조합중에서 가장 점수가 높은 햄버거의 점수를 찾는 문제이다.

```java

static void comb(int start, int sum, int score, int pre) {

    if(sum > cal) {
        max = Math.max(max, score-pre);
        return;
    }
    if(start == n) {
        max = Math.max(max, score);
    }

    for(int i = start; i < n; i++) {

        comb(i+1, sum+list.get(i).cal, score + list.get(i).score, list.get(i).score);

    }

}

```

조합을 사용해서 파라미터로 `선택된 재료 인덱스 값, 선택된 재료의 점수 합, 선택된 재료의 점수`를 넘겨주어 계산한다.<br/>
제한 칼로리가 넘었을 때 종료하기 때문에 이전에 선택된 재료는 빼야한다.<br/>
그리고 마지막 재료를 사용했는데 제한 칼로리를 넘지 않았을 경우도 생각해줘서 `start == n`를 따로 처리해주었다.


## :black_nib: **Review**
- 햄버거 재료 개수가 최대 20개이며 재료 순서가 상관없기 때문에 조합으로 문제를 해결했다.
    - 처음엔 최대 칼로리가 있고 그 칼로리를 넘지않고 점수를 높여야 해서 dp를 사용한 조합 최적화 문제인 배낭 문제를 생각했었다.<br/> 하지만 제한 칼로리 최대가 10000이라 dp를 이용하여 푸는 것이 그렇게 효율적이지 않을 것이라고 판단했고 최대 조합 원소 개수가 20개라 기본 조합을 적용하는 것이 더 쉽게 풀릴 것이라고 생각했다.
    - 배낭 문제에서 dp를 사용하는 경우는 탐색해야 할 원소가 많아 연산의 시간이 오래걸릴 경우 사용하는 것이 좋다.
- dfs에서 종료조건이 제한 칼로리를 넘었을 때라서 이전에 선택된 재료를 알아야 한다.
    - 더하지 않아도 될 점수를 더하고 이를 빼는 작업이 불필요한 작업을 하는 것같아 이전 재료의 점수를 넘겨주지 않고, 이전 재료 값을 빼지 않는 방법이 없을까 고민을 했는데 찾지 못했다.
