# [1563] 개근상

## :pushpin: **Algorithm**

DP

## :round_pushpin: **Logic**

```java
// [날짜][지각 횟수][연속 결석 횟수]
int[][][] dp = new int[N][2][3];

for (int index = 1; index < N; index++) {
    // 지각도 한 적 없고, 연속된 결석도 없으려면,
    // 앞에서 지각이 없는 경우와, 연속된 결석이 1번인 경우, 2번인 경우의 합!
    dp[index][0][0] = (dp[index - 1][0][0] + dp[index - 1][0][1] + dp[index - 1][0][2]) % MOD;

    // 지각한 적 없고, 연속된 결석이 1개이려면,
    // 지각이 없고, 연속된 결석이 없는 경우에 결석 1개가 붙어야 함!
    dp[index][0][1] = dp[index - 1][0][0];

    // 지각한 적 없고, 연속된 결석이 2번이려면
    // 앞에서 연속된 결석이 1번인 경우에 결석 1개가 붙어야 함!
    dp[index][0][2] = dp[index - 1][0][1];

    // 지각을 1번 하고, 연속된 결석이 없으려면
    // 앞에서는 지각을 하지 않고, 결석이 0 ~ 2번이거나,
    // 앞에서 지각을 1번 하고, 결석이 0 ~ 2번했어야 함!
    dp[index][1][0] = (dp[index - 1][0][0] + dp[index - 1][0][1] + dp[index - 1][0][2] + dp[index - 1][1][0] + dp[index - 1][1][1] + dp[index - 1][1][2]) % MOD;

    // 위와 동일!
    dp[index][1][1] = dp[index - 1][1][0];
    dp[index][1][2] = dp[index - 1][1][1];
}
```

- 날짜, 지각 횟수, 연속된 결석 횟수를 나타내는 배열을 사용한다.
- 지각 횟수와 연속된 결석 횟수에 따라 경우를 나눠 메모이제이션을 사용한다.

## :black_nib: **Review**
- 3차원 배열을 사용해야 하는 아이디어를 참고했다.
- 각 경우를 나눠 생각해보면 점화식이 도출되었는데, 3차원 배열을 떠올리기가 어려운 것 같다.