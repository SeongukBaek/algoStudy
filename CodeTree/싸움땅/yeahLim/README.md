# [삼성 SW 역량테스트] 싸움땅

## :pushpin: **Algorithm**

구현, 시뮬레이션

## :round_pushpin: **Logic**

```java
private static Queue<Integer>[][] map;

map[i][j] = new PriorityQueue<>((o1, o2) -> o2 - o1);
```

- 좌표 당 총이 하나가 아니라 둘 이상이 올 수가 있기 때문에 map을 단순 2차원 배열로 구현한 것이 아니라 2차원 우선순위 큐 배열을 이용했다.
- 문제에서 가장 공격력이 큰 무기를 선택하는 경우에만 요구했기 때문이다.

```java
static void runRound() {
    for(int i=0; i<m; i++) {
        movePlayer(player[i]);
        play(i);
    }
}
```

- runRound()는 한 개의 라운드를 실행하는 메소드이다.
- 먼저 movePlayer()를 통해 순서대로 플레이어가 한 명씩 이동한다.
- 이동 후, play()를 실행한다. 
    - 그 좌표에 다른 플레이어가 있을 경우, fight()를 통해 승자와 패자를 가린다.
    - 플레이어가 없을 경우, checkGun()을 통해 자기가 가지고 있는 총과 해당 좌표의 총 중에 공격력이 큰 총을 소유한다.

## :black_nib: **Review**
- 구현을 자체는 어렵지 않았다. 
- 다만 구현이 쉽다보니 중간에 잘 돌아가는지 확인도 안하고 한 번에 모든 코드를 구현했다. 구현 후 실행해보니 정답과 달랐다. 그래서 정답이 왜 틀렸는지 한창 찾았다. 
 - 틀린 이유는 point값에 기존 포인트 값에서 현재 얻은 포인트를 더해줘야하는데 (+=), 아예 현재포인트로 갱신(=)했기 때문이었다.
 - 다음부터는 한번에 구현하지말고 중간엔 코드가 잘 실행되는지 확인해야겠다.
 - 또, 디버깅할때, 볼 수 있는 모든 변수를 한 번에 확인하자. 그럼 더욱 더 빨리 어디서 틀렸는지 알아챌 수 있을 것이다. 